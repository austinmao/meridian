#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.10"
# dependencies = ["pyyaml"]
# ///
"""
Spec-kit capture hook for PostToolUse events.
Captures spec-kit slash command outputs and writes them to Meridian task system.
"""

import sys
import json
import re
from pathlib import Path
from datetime import datetime
from typing import Any
import os

import yaml

# Spec-kit command patterns
SPECKIT_COMMANDS = {
    "/speckit.constitution": "constitution",
    "/speckit.specify": "specify",
    "/speckit.plan": "plan",
    "/speckit.tasks": "tasks",
    "/speckit.implement": "implement",
}


def get_project_dir() -> Path:
    """Get project directory from environment."""
    project_dir = os.environ.get("CLAUDE_PROJECT_DIR", "")
    if not project_dir:
        return Path.cwd()
    return Path(project_dir)


def get_next_task_id(meridian_dir: Path) -> str:
    """Find the next available TASK-### ID."""
    tasks_dir = meridian_dir / "tasks"
    if not tasks_dir.exists():
        tasks_dir.mkdir(parents=True)
        return "TASK-001"

    existing_ids = []
    for folder in tasks_dir.iterdir():
        if folder.is_dir() and folder.name.startswith("TASK-"):
            match = re.match(r"TASK-(\d+)", folder.name)
            if match:
                existing_ids.append(int(match.group(1)))

    next_id = max(existing_ids, default=0) + 1
    return f"TASK-{next_id:03d}"


def get_active_draft_task(meridian_dir: Path) -> str | None:
    """Find the most recent draft/spec_pending task."""
    backlog_file = meridian_dir / "task-backlog.yaml"
    if not backlog_file.exists():
        return None

    try:
        with open(backlog_file) as f:
            backlog = yaml.safe_load(f)

        if not backlog or "tasks" not in backlog:
            return None

        # Find most recent draft task
        for task in reversed(backlog.get("tasks", [])):
            if task.get("status") in ("draft", "spec_pending"):
                return task.get("id")
    except Exception:
        pass

    return None


def create_task_folder(meridian_dir: Path, task_id: str, title: str, requirements: list[str]) -> Path:
    """Create a new Meridian task folder with YAML, plan, and context files."""
    task_folder = meridian_dir / "tasks" / task_id
    task_folder.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().isoformat()

    # Create TASK-###.yaml
    yaml_content = {
        "id": task_id,
        "title": title[:80] if title else "Spec-kit generated task",
        "status": "draft",
        "priority": "P2",
        "created_at": timestamp,
        "updated_at": timestamp,
        "source": "spec-kit",
        "objective": "Generated from spec-kit /speckit.specify command. Review and approve before implementation.",
        "constraints": [],
        "requirements": [],
        "deliverables": [],
        "implementation_notes": [
            "CRITICAL: Review and approve this task before implementation",
            "Generated by spec-kit - validate requirements are complete"
        ],
        "risks": [],
        "validation": {
            "commands": ["pnpm lint", "pnpm typecheck", "pnpm test"],
            "manual_steps": ["Verify all requirements are met"]
        },
        "links": {"files": [], "docs": []},
        "notes": []
    }

    # Add requirements
    for i, req in enumerate(requirements, 1):
        yaml_content["requirements"].append({
            "id": f"R{i}",
            "description": req,
            "acceptance_criteria": "- To be defined during review",
            "status": "todo"
        })

    yaml_file = task_folder / f"{task_id}.yaml"
    with open(yaml_file, "w") as f:
        yaml.dump(yaml_content, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

    # Create empty plan file
    plan_file = task_folder / f"{task_id}-plan.md"
    plan_file.write_text(f"# Implementation Plan â€” {task_id}\n\n*Plan pending from /speckit.plan*\n")

    # Create context file
    context_file = task_folder / f"{task_id}-context.md"
    context_file.write_text(f"""# Context & Progress â€” {task_id}

## {timestamp}
- Task created from spec-kit /speckit.specify
- Status: draft (pending approval)
- Requirements captured: {len(requirements)}

---
*Use /speckit.plan to generate technical approach*
*Use /speckit.tasks to generate implementation checklist*
""")

    return task_folder


def update_task_backlog(meridian_dir: Path, task_id: str, title: str) -> None:
    """Add or update task in task-backlog.yaml."""
    backlog_file = meridian_dir / "task-backlog.yaml"

    if backlog_file.exists():
        with open(backlog_file) as f:
            backlog = yaml.safe_load(f) or {}
    else:
        backlog = {"tasks": []}

    if "tasks" not in backlog:
        backlog["tasks"] = []

    # Check if task already exists
    for task in backlog["tasks"]:
        if task.get("id") == task_id:
            task["status"] = "draft"
            task["title"] = title[:80]
            break
    else:
        # Add new task
        backlog["tasks"].append({
            "id": task_id,
            "title": title[:80] if title else "Spec-kit generated task",
            "priority": "P2",
            "status": "draft",
            "path": f".meridian/tasks/{task_id}/"
        })

    with open(backlog_file, "w") as f:
        # Write header comment
        f.write("# Task Backlog\n")
        f.write("# Simple index of tasks - detailed definitions live in .meridian/tasks/TASK-###/\n\n")
        yaml.dump(backlog, f, default_flow_style=False, sort_keys=False, allow_unicode=True)


def update_task_plan(meridian_dir: Path, task_id: str, plan_content: str) -> Path:
    """Update the plan file for a task."""
    task_folder = meridian_dir / "tasks" / task_id
    plan_file = task_folder / f"{task_id}-plan.md"

    timestamp = datetime.now().isoformat()
    content = f"""# Implementation Plan â€” {task_id}

Generated: {timestamp}
Source: spec-kit /speckit.plan

---

{plan_content}

---
*Review and approve this plan before implementation*
"""
    plan_file.write_text(content)
    return plan_file


def update_task_context_with_tasks(meridian_dir: Path, task_id: str, tasks: list[str]) -> Path:
    """Add task checklist to context file."""
    task_folder = meridian_dir / "tasks" / task_id
    context_file = task_folder / f"{task_id}-context.md"

    timestamp = datetime.now().isoformat()

    # Read existing content
    existing = context_file.read_text() if context_file.exists() else f"# Context & Progress â€” {task_id}\n"

    # Add task checklist
    checklist = "\n".join([f"- [ ] {task}" for task in tasks])
    new_section = f"""
## {timestamp} â€” Task Breakdown
Generated from /speckit.tasks

### Implementation Checklist
{checklist}

"""

    # Append to file
    context_file.write_text(existing + new_section)
    return context_file


def extract_speckit_command(tool_name: str, tool_input: dict) -> str | None:
    """Extract spec-kit command from SlashCommand tool usage."""
    if tool_name != "SlashCommand":
        return None

    command = tool_input.get("command", "")
    for speckit_cmd in SPECKIT_COMMANDS:
        if command.startswith(speckit_cmd):
            return SPECKIT_COMMANDS[speckit_cmd]
    return None


def extract_title_from_command(command: str) -> str:
    """Extract a title from the spec-kit command arguments."""
    # Remove the command prefix to get the description
    for prefix in SPECKIT_COMMANDS.keys():
        if command.startswith(prefix):
            title = command[len(prefix):].strip()
            return title if title else "Spec-kit generated task"
    return "Spec-kit generated task"


def parse_requirements(output: str) -> list[str]:
    """Parse requirements from spec-kit specify output."""
    lines = output.split("\n")
    requirements = []
    current_req = None

    for line in lines:
        # Look for requirement patterns
        if line.strip().startswith("- ") or line.strip().startswith("* "):
            if current_req:
                requirements.append(current_req)
            current_req = line.strip()[2:]
        elif current_req and line.strip():
            current_req += f" {line.strip()}"

    if current_req:
        requirements.append(current_req)

    return requirements


def parse_tasks(output: str) -> list[str]:
    """Parse tasks from spec-kit tasks output."""
    tasks = []
    lines = output.split("\n")

    for line in lines:
        line = line.strip()
        # Match task patterns like "1. Task description" or "- [ ] Task"
        if re.match(r"^\d+\.", line) or line.startswith("- [ ]"):
            task_text = re.sub(r"^(\d+\.|\- \[ \])\s*", "", line)
            if task_text:
                tasks.append(task_text)

    return tasks


def main() -> int:
    try:
        input_data = json.load(sys.stdin)
        sys.stdin.close()  # Close stdin after reading

        tool_name = input_data.get("tool", "")
        tool_input = input_data.get("input", {})
        tool_output = input_data.get("output", "")

        # Check if this is a spec-kit command
        speckit_type = extract_speckit_command(tool_name, tool_input)
        if not speckit_type:
            return 0  # Not a spec-kit command, pass through

        project_dir = get_project_dir()
        meridian_dir = project_dir / ".meridian"

        # Process based on spec-kit command type
        result_info = None
        command = tool_input.get("command", "")

        if speckit_type == "specify":
            # Parse requirements and create Meridian task
            requirements = parse_requirements(tool_output)
            title = extract_title_from_command(command)

            # Create new task
            task_id = get_next_task_id(meridian_dir)
            task_folder = create_task_folder(meridian_dir, task_id, title, requirements)
            update_task_backlog(meridian_dir, task_id, title)

            result_info = f"\n[SPECKIT â†’ MERIDIAN] Created {task_id} with {len(requirements)} requirements\n"
            result_info += f"  ğŸ“ Task folder: {task_folder.relative_to(project_dir)}\n"
            result_info += f"  ğŸ“‹ Status: draft (pending approval)\n"
            result_info += "Next steps:\n"
            result_info += f"  1. Review {task_id}.yaml requirements\n"
            result_info += "  2. Run /speckit.plan to generate technical approach\n"
            result_info += "  3. Approve and change status to 'todo' to begin work\n"

        elif speckit_type == "plan":
            # Find active draft task or create one
            task_id = get_active_draft_task(meridian_dir)
            if not task_id:
                # Create a new task for the plan
                task_id = get_next_task_id(meridian_dir)
                create_task_folder(meridian_dir, task_id, "Spec-kit planned task", [])
                update_task_backlog(meridian_dir, task_id, "Spec-kit planned task")

            # Update the plan file
            plan_file = update_task_plan(meridian_dir, task_id, tool_output)

            result_info = f"\n[SPECKIT â†’ MERIDIAN] Updated {task_id} plan\n"
            result_info += f"  ğŸ“„ Plan file: {plan_file.relative_to(project_dir)}\n"
            result_info += "Next steps:\n"
            result_info += "  1. Review the generated plan\n"
            result_info += "  2. Run /speckit.tasks for implementation checklist\n"
            result_info += "  3. Approve and change status to 'todo'\n"

        elif speckit_type == "tasks":
            # Find active draft task
            task_id = get_active_draft_task(meridian_dir)
            if not task_id:
                result_info = "\n[SPECKIT] No draft task found. Run /speckit.specify first.\n"
            else:
                tasks = parse_tasks(tool_output)
                context_file = update_task_context_with_tasks(meridian_dir, task_id, tasks)

                result_info = f"\n[SPECKIT â†’ MERIDIAN] Added {len(tasks)} tasks to {task_id}\n"
                result_info += f"  ğŸ“ Context file: {context_file.relative_to(project_dir)}\n"
                result_info += "Next steps:\n"
                result_info += "  1. Review the implementation checklist\n"
                result_info += f"  2. Approve {task_id} and change status to 'todo'\n"
                result_info += "  3. Begin implementation following the checklist\n"

        elif speckit_type == "implement":
            task_id = get_active_draft_task(meridian_dir)
            if task_id:
                result_info = f"\n[SPECKIT] Implementation running for {task_id}\n"
                result_info += f"  ğŸ“ Update {task_id}-context.md with progress notes\n"
            else:
                result_info = "\n[SPECKIT] /speckit.implement detected\n"
                result_info += "  ğŸ“ Remember to update task context with progress\n"

        # Output info to user (shown in transcript)
        if result_info:
            print(result_info)

        return 0  # Non-blocking

    except Exception as e:
        sys.stderr.write(f"Speckit capture error: {e}\n")
        return 0  # Non-blocking - fail gracefully


if __name__ == "__main__":
    sys.exit(main())
